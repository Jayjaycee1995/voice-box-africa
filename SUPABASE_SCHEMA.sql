-- Enable UUID extension
create extension if not exists "uuid-ossp";

do $$
begin
  create type user_role as enum ('client', 'talent', 'admin');
exception
  when duplicate_object then null;
end $$;
do $$
begin
  create type gig_status as enum ('open', 'assigned', 'completed', 'cancelled');
exception
  when duplicate_object then null;
end $$;
do $$
begin
  create type proposal_status as enum ('pending', 'accepted', 'rejected');
exception
  when duplicate_object then null;
end $$;
do $$
begin
  create type invitation_status as enum ('pending', 'accepted', 'declined');
exception
  when duplicate_object then null;
end $$;
do $$
begin
  create type gig_visibility as enum ('public', 'invite-only');
exception
  when duplicate_object then null;
end $$;

-- Create Users Table (extends auth.users)
create table public.users (
  id uuid references auth.users not null primary key,
  email text unique not null,
  name text,
  role user_role default 'client',
  bio text,
  skills text, -- JSON string or comma-separated
  portfolio_url text,
  profile_image text,
  company_name text,
  industry text,
  location text,
  price_per_word numeric(10, 2),
  equipment text,
  is_available boolean default true,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS for Users
alter table public.users enable row level security;

-- Policies for Users
create policy "Public profiles are viewable by everyone" 
  on public.users for select 
  using ( true );

create policy "Users can update own profile" 
  on public.users for update 
  using ( auth.uid() = id );

-- Trigger to handle new user signup
create or replace function public.handle_new_user() 
returns trigger 
security definer set search_path = public
as $$
begin
  insert into public.users (
    id, 
    email, 
    name, 
    role, 
    bio, 
    skills, 
    company_name, 
    industry, 
    location, 
    price_per_word, 
    equipment
  )
  values (
    new.id, 
    new.email, 
    new.raw_user_meta_data->>'name', 
    coalesce((new.raw_user_meta_data->>'role')::public.user_role, 'client'::public.user_role),
    new.raw_user_meta_data->>'bio',
    new.raw_user_meta_data->>'skills',
    new.raw_user_meta_data->>'company_name',
    new.raw_user_meta_data->>'industry',
    new.raw_user_meta_data->>'location',
    nullif(new.raw_user_meta_data->>'price_per_word', '')::numeric,
    new.raw_user_meta_data->>'equipment'
  );
  return new;
exception when others then
  raise warning 'Error in handle_new_user: %', SQLERRM;
  raise exception 'Database error saving new user: %', SQLERRM;
end;
$$ language plpgsql;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Create Gigs Table
create table public.gigs (
  id bigint generated by default as identity primary key,
  client_id uuid references public.users(id) on delete cascade not null,
  title text not null,
  description text not null,
  budget decimal(10, 2) not null,
  deadline date not null,
  category text,
  accent text,
  duration text,
  word_count integer,
  status gig_status default 'open',
  language text,
  tone text,
  visibility gig_visibility default 'public',
  delivery_file text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS for Gigs
alter table public.gigs enable row level security;

-- Policies for Gigs
create policy "Public gigs are viewable by everyone" 
  on public.gigs for select 
  using ( visibility = 'public' );

create policy "Clients can create gigs" 
  on public.gigs for insert 
  with check ( auth.uid() = client_id );

create policy "Clients can update own gigs" 
  on public.gigs for update 
  using ( auth.uid() = client_id );

-- Create Proposals Table
create table public.proposals (
  id bigint generated by default as identity primary key,
  gig_id bigint references public.gigs(id) on delete cascade not null,
  talent_id uuid references public.users(id) on delete cascade not null,
  cover_letter text not null,
  bid_amount decimal(10, 2) not null,
  status proposal_status default 'pending',
  demo_url text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS for Proposals
alter table public.proposals enable row level security;

-- Policies for Proposals
create policy "Talents can view own proposals" 
  on public.proposals for select 
  using ( auth.uid() = talent_id );

create policy "Clients can view proposals for their gigs" 
  on public.proposals for select 
  using ( exists ( select 1 from public.gigs where gigs.id = proposals.gig_id and gigs.client_id = auth.uid() ) );

create policy "Talents can create proposals" 
  on public.proposals for insert 
  with check ( auth.uid() = talent_id );

-- Create Messages Table
create table public.messages (
  id bigint generated by default as identity primary key,
  sender_id uuid references public.users(id) on delete cascade not null,
  receiver_id uuid references public.users(id) on delete cascade not null,
  content text not null,
  is_read boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS for Messages
alter table public.messages enable row level security;

-- Policies for Messages
create policy "Users can view own messages" 
  on public.messages for select 
  using ( auth.uid() = sender_id or auth.uid() = receiver_id );

create policy "Users can send messages" 
  on public.messages for insert 
  with check ( auth.uid() = sender_id );

-- Create Invitations Table
create table public.invitations (
  id bigint generated by default as identity primary key,
  client_id uuid references public.users(id) on delete cascade not null,
  talent_id uuid references public.users(id) on delete cascade not null,
  gig_id bigint references public.gigs(id) on delete cascade not null,
  message text,
  status invitation_status default 'pending',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS for Invitations
alter table public.invitations enable row level security;

-- Policies for Invitations
create policy "Users can view own invitations" 
  on public.invitations for select 
  using ( auth.uid() = client_id or auth.uid() = talent_id );

-- Create Demos Table
create table public.demos (
  id bigint generated by default as identity primary key,
  user_id uuid references public.users(id) on delete cascade not null,
  title text not null,
  file_path text not null,
  duration text,
  type text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS for Demos
alter table public.demos enable row level security;

-- Policies for Demos
create policy "Demos are viewable by everyone" 
  on public.demos for select 
  using ( true );

create policy "Users can upload demos" 
  on public.demos for insert 
  with check ( auth.uid() = user_id );

-- Storage Buckets
insert into storage.buckets (id, name, public) values ('demos', 'demos', true) on conflict do nothing;
insert into storage.buckets (id, name, public) values ('profile-images', 'profile-images', true) on conflict do nothing;
insert into storage.buckets (id, name, public) values ('gig-attachments', 'gig-attachments', true) on conflict do nothing;

-- Storage Policies (to allow uploads)
create policy "Public Access to Demos" on storage.objects for select using ( bucket_id = 'demos' );
create policy "Authenticated Users can Upload Demos" on storage.objects for insert with check ( bucket_id = 'demos' and auth.role() = 'authenticated' );

create policy "Public Access to Profile Images" on storage.objects for select using ( bucket_id = 'profile-images' );
create policy "Authenticated Users can Upload Profile Images" on storage.objects for insert with check ( bucket_id = 'profile-images' and auth.role() = 'authenticated' );

create policy "Public Access to Gig Attachments" on storage.objects for select using ( bucket_id = 'gig-attachments' );
create policy "Authenticated Users can Upload Gig Attachments" on storage.objects for insert with check ( bucket_id = 'gig-attachments' and auth.role() = 'authenticated' );
